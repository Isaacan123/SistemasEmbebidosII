{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"Lab01/","title":"Lab 01 \u2013 FreeRTOS Task Creation and Scheduling","text":""},{"location":"Lab01/#activity-goals","title":"Activity Goals","text":"<ul> <li>Understand FreeRTOS task creation and scheduling</li> <li>Implement GPIO control for LED blinking on ESP32</li> <li>Manage time delays using <code>vTaskDelay</code></li> <li>Configure task priorities and stack sizes correctly</li> </ul>"},{"location":"Lab01/#materials","title":"Materials","text":"<p>No materials required</p>"},{"location":"Lab01/#code-example","title":"Code Example","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_2\n\nstatic const char *TAG = \"LAB1\";\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void hello_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"hello_task says hi, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1 (two tasks)\");\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 2, NULL);\n}\n</code></pre>"},{"location":"Lab01/#exercises","title":"Exercises","text":"<p>Priority Experiment: Change <code>hello_task</code> priority from 5 to 2. Does behavior change? Why? - Yes. Lower priority numbers execute less frequently, allowing the higher-priority blink task to run more often.</p> <p>Starvation Demo: Remove <code>vTaskDelay(...)</code> from <code>hello_task</code>. What happens? - The LED stops blinking because <code>hello_task</code> monopolizes CPU time, starving other tasks. - Fix: Blocking tasks with <code>vTaskDelay</code> allows the scheduler to handle other tasks fairly.</p>"},{"location":"Lab01/#lab-02","title":"Lab 02","text":""},{"location":"Lab01/#code-of-exercise-lab02","title":"Code Of exercise LAB02","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB2\";\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    int value = 0;\n    while (1) {\n        value++;\n        if (xQueueSend(q_numbers, &amp;value, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n        vTaskDelay(pdMS_TO_TICKS(20));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    int rx = 0;\n    while (1) {\n        if (xQueueReceive(q_numbers, &amp;rx, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n            vTaskDelay(pdMS_TO_TICKS(300));\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n    q_numbers = xQueueCreate(20, sizeof(int));\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"Lab01/#exercises_1","title":"Exercises","text":""},{"location":"Lab01/#1-make-the-producer-faster","title":"1. Make the producer faster","text":"<ul> <li>Change: Producer delay <code>200ms \u2192 20ms</code>.</li> <li>Effect:   With this change, the producer generates data every 20 ms, but the consumer does not keep up.  </li> <li>Observation: You will see \u201cQueue full\u201d when the producer tries to send data faster than the consumer can process.  </li> <li>Reason: The consumer is slower than the producer, so the queue fills up quickly.</li> </ul>"},{"location":"Lab01/#2-increase-the-queue-length","title":"2. Increase the queue length","text":"<ul> <li>Change: Queue length <code>5 \u2192 20</code>.</li> <li>Effect: </li> <li>The consumer now has more buffer space to store data.  </li> <li>After filling those 20 slots, the consumer will start losing data again if it cannot process fast enough.  </li> <li>Conclusion: Increasing queue length delays data loss but does not solve the imbalance between producer and consumer speeds.</li> </ul>"},{"location":"Lab01/#3-make-the-consumer-slow","title":"3. Make the consumer \u201cslow\u201d","text":"<ul> <li>Change: After a successful receive, add:   ```c   vTaskDelay(pdMS_TO_TICKS(300)); /</li> </ul> <p>## What pattern is happening now (buffering / backlog)?</p> <p>With this code we can see that the system in the first seconds the producer will load the 20 spaces of the queue. The consumer is slower, so it will be processing data item 1 while the producer has already sent items 2, 3, 4, ...  </p> <p>Therefore, our queue will always be full, because the consumer takes 300 ms to process a single piece of data, and in that time the producer tried to send 15 new pieces of data (<code>300 / 20 = 15</code>).  </p>"},{"location":"Lab01/#lab-03","title":"Lab 03","text":""},{"location":"Lab01/#code-of-exercise-lab03a","title":"Code of exercise LAB03A","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3A\";\n\nstatic volatile int shared_counter = 0;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        // NOT safe: read-modify-write without protection\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3A (race demo)\");\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre>"},{"location":"Lab01/#part-a-why-can-the-counter-be-wrong","title":"Part A: Why can the counter be wrong?","text":"<p>The counter can be wrong because Task A copies the counter value into its local memory, but before finishing the update the system pauses Task A and gives control to Task B, which reads the same value (100), increments it to 101, and stores it; when Task A resumes it still believes the counter is 100, increments it to 101, and overwrites Task B\u2019s update, so although two increments were made the counter only increased by 1 and information was lost due to a race condition.</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n#define LED_GPIO GPIO_NUM_2   \n#define BUTTON5_GPIO  GPIO_NUM_3\nint Read_button5 = 0; // Aqu\u00ed guardamos la lectura\n\nvoid read_button_task5(void *pvParameters)\n{\n    gpio_set_direction(BUTTON5_GPIO, GPIO_MODE_INPUT);\n    gpio_set_pull_mode(BUTTON5_GPIO, GPIO_PULLUP_ONLY);\n  print(my name is isaac_rec.name)\n\n    while (1) {\n        Read_button5 = gpio_get_level(BUTTON5_GPIO);\n        vTaskDelay(pdMS_TO_TICKS(20)); // cada 20ms\n    }\n}\n    while (1) {\n        Read_button5 = gpio_get_level(BUTTON5_GPIO);\n        vTaskDelay(pdMS_TO_TICKS(20)); // cada 20ms\n    }\n}\n// TAG para los mensajes del log (ESP_LOGI)\nstatic const char *TAG = \"LAB3A\";\nstruct patient{\n    int counter=0;\n    char[10] name=\"\";\n};\n\n}\nstatic void HEARTBEAT(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(2000));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(2000));\n    }\n}\n\nstatic void Alive(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"Alive, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    struct patient isaac_sends;\n    isaac_sends.name = \"isaac\"\n\n    while (1) {\n        isaac_sends.counter=isaac.counter+1;\n\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;isaac, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    struct patient isaac_rec;\n\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;isaac_rec, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n            print(my name is isaac_rec.name and im counting to isaac_rec.counter)\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n\n    q_numbers = xQueueCreate(7, sizeof(counter)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;//crash m rogram\n    }\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3A (race demo)\");\n\n    // Crea varias tareas que compiten por incrementar shared_counter.\n    // 1 tarea \"TaskA\"\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n\n    // 4 tareas \"TaskB\" (todas compiten tambi\u00e9n por el mismo contador)\n    // OJO: todas tienen el mismo nombre de task (\"incB\") y el mismo par\u00e1metro \"TaskB\".\n    // Esto dificulta distinguirlas en depuraci\u00f3n.\n    xTaskCreate(HEARTBEAT, \"blink_task\", 2048, \"TaskA\", 1, NULL);\n    xTaskCreate(Alive, \"Alive\", 2048, \"TaskB\", 2, NULL);\n    xTaskCreate(producer_task, \"TaskC\", 2048, NULL, 3, NULL);\n    xTaskCreate(consumer_task, \"TaskD\", 2048, NULL, 4, NULL);\n    xTaskCreate(read_button_task5, \"incE\", 2048, \"Task5\", 5, NULL);\n    xTaskCreate( read_button_task6, \"incF\", 2048, \"Task6\", 6, NULL);\n\n}\n</code></pre>"},{"location":"Lab01/#exercises_2","title":"Exercises","text":""},{"location":"Lab01/#remove-the-mutex-again-do-you-ever-see-weird-behavior","title":"Remove the mutex again. Do you ever see weird behavior?","text":"<p>Yes, the counter will grow slower than expected or show inconsistent values.</p>"},{"location":"Lab01/#change-priorities-taska-priority-6-taskb-priority-4-what-do-you-expect-and-why","title":"Change priorities: TaskA priority 6, TaskB priority 4. What do you expect and why?","text":"<p>Task A will interrupt Task B almost every time it finishes its waiting period, so Task A dominates execution.</p>"},{"location":"Lab01/#in-one-sentence-what-does-a-mutex-guarantee","title":"In one sentence: what does a mutex \u201cguarantee\u201d?","text":"<p>A mutex guarantees that only one task can access a shared resource at any given time.</p>"},{"location":"Lab01/#extra-mini-challenges","title":"Extra mini-challenges","text":""},{"location":"Lab01/#heartbeat-work-task","title":"Heartbeat + work task","text":"<p>Add a third task that prints \u201calive\u201d every 2 seconds.</p>"},{"location":"Lab01/#queue-with-struct","title":"Queue with struct","text":"<p>Send a struct: <code>{int id; int value;}</code></p>"},{"location":"Lab01/#mutex-around-a-shared-peripheral","title":"Mutex around a shared peripheral","text":"<p>Make two tasks write to the same log message format (simulate \u201cshared UART resource\u201d) and guard it with a mutex.</p>"},{"location":"Lab01/#results","title":"Results","text":"<p>--</p>"},{"location":"Lab01/#labs-codes-running","title":"Labs codes running","text":"<p>Enlace directo Enlace directo</p>"},{"location":"Lab02/","title":"Lab 02 \u2013 FreeRTOS Multi-Tasking: Queues, Mutexes and Structs","text":""},{"location":"Lab02/#activity-goals","title":"Activity Goals","text":"<ul> <li>Implement a complex system with 7 concurrent tasks.</li> <li>Manage data communication using Queues with custom <code>struct</code> types.</li> <li>Protect shared hardware resources (GPIO) using Mutexes.</li> <li>Centralize system events and errors through a dedicated Logging Task.</li> </ul>"},{"location":"Lab02/#materials","title":"Materials","text":"<ul> <li>ESP32 Development Board</li> <li>1x Push Button</li> <li>1x LED (Internal or External)</li> <li>Resistors and Jumper wires</li> </ul>"},{"location":"Lab02/#code-of-exercise-lab02","title":"Code Of exercise LAB02","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO 2\n#define BUTTON_GPIO 4 \n\nstatic const char *TAG = \"LAB02\";\n\n// Estructura para la comunicaci\u00f3n por cola\ntypedef struct {\n    int id;\n    int counter;\n    char name[10];\n} patient_t;\n\n// Handles globales de FreeRTOS\nstatic QueueHandle_t q_patient;\nstatic QueueHandle_t q_logs;\nstatic SemaphoreHandle_t button_mutex;\n\n// 1. Heartbeat Task: Indica que el sistema est\u00e1 corriendo\nstatic void heartbeat_task(void *pv) {\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(500));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n\n// 2. Alive Task: Mensaje peri\u00f3dico en consola\nstatic void alive_task(void *pv) {\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"System is Alive, count=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(2000));\n    }\n}\n\n// 3. Queue Struct Send (Producer)\nstatic void producer_task(void *pv) {\n    patient_t p;\n    p.id = 101;\n    p.counter = 0;\n    strcpy(p.name, \"Isaac\");\n    while (1) {\n        p.counter++;\n        if (xQueueSend(q_patient, &amp;p, pdMS_TO_TICKS(10)) == pdPASS) {\n            ESP_LOGI(TAG, \"Data sent to queue for: %s\", p.name);\n        }\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\n// 4. Queue Struct Receive (Consumer)\nstatic void consumer_task(void *pv) {\n    patient_t p_rec;\n    while (1) {\n        if (xQueueReceive(q_patient, &amp;p_rec, portMAX_DELAY)) {\n            ESP_LOGI(TAG, \"Queue Recv -&gt; Name: %s, ID: %d, Counter: %d\", p_rec.name, p_rec.id, p_rec.counter);\n        }\n    }\n}\n\n// 5 &amp; 6. Mutex Reading Tasks: Dos tareas acceden al mismo bot\u00f3n\nstatic void button_task(void *pv) {\n    char *task_id = (char *)pv;\n    while (1) {\n        if (xSemaphoreTake(button_mutex, portMAX_DELAY)) {\n            if (gpio_get_level(BUTTON_GPIO) == 0) {\n                char *msg = \"Event: Button Pressed detected\";\n                xQueueSend(q_logs, &amp;msg, 0);\n            }\n            xSemaphoreGive(button_mutex);\n        }\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n\n// 7. Error Logging Task: Centraliza los mensajes de log\nstatic void logger_task(void *pv) {\n    char *msg;\n    while (1) {\n        if (xQueueReceive(q_logs, &amp;msg, portMAX_DELAY)) {\n            ESP_LOGW(\"LOGGER_SERVICE\", \"%s\", msg);\n        }\n    }\n}\n\nvoid app_main(void) {\n    // Inicializaci\u00f3n de colas y sem\u00e1foros\n    q_patient = xQueueCreate(5, sizeof(patient_t));\n    q_logs = xQueueCreate(10, sizeof(char *));\n    button_mutex = xSemaphoreCreateMutex();\n\n    // Configuraci\u00f3n de Hardware\n    gpio_reset_pin(BUTTON_GPIO);\n    gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);\n    gpio_pullup_en(BUTTON_GPIO);\n\n    // Despliegue de las 7 tareas con diferentes prioridades\n    xTaskCreate(heartbeat_task, \"Heart\", 2048, NULL, 1, NULL);\n    xTaskCreate(alive_task, \"Alive\", 2048, NULL, 1, NULL);\n    xTaskCreate(producer_task, \"Prod\", 2048, NULL, 2, NULL);\n    xTaskCreate(consumer_task, \"Cons\", 2048, NULL, 2, NULL);\n    xTaskCreate(button_task, \"Btn_T5\", 2048, \"Task 5\", 3, NULL);\n    xTaskCreate(button_task, \"Btn_T6\", 2048, \"Task 6\", 3, NULL);\n    xTaskCreate(logger_task, \"Log_T7\", 2048, NULL, 4, NULL);\n}\n</code></pre>"},{"location":"Lab02/#exercises","title":"Exercises","text":"<p>Mutex Necessity: \u00bfQu\u00e9 pasar\u00eda si las Tareas 5 y 6 no usaran un Mutex para leer el bot\u00f3n? - Observaci\u00f3n: Aunque el hardware permite la lectura simult\u00e1nea, en perif\u00e9ricos m\u00e1s complejos (como un sensor I2C), el sistema colapsar\u00eda.  - Conclusi\u00f3n: El Mutex asegura que la secci\u00f3n cr\u00edtica del c\u00f3digo sea accedida por un solo proceso a la vez, manteniendo la integridad de los datos.</p> <p>Data Structs in Queues: \u00bfCu\u00e1l es la ventaja de usar una <code>struct</code> en la cola en lugar de solo un entero? - Respuesta: Permite enviar paquetes de informaci\u00f3n completos (ID, Nombres, Valores). - Efecto: El sistema se vuelve m\u00e1s robusto y organizado, facilitando el procesamiento de datos complejos entre el productor y el consumidor.</p> <p>Centralized Logging: \u00bfC\u00f3mo beneficia la Tarea 7 al rendimiento del sistema? - Raz\u00f3n: La escritura en consola (Serial) es una operaci\u00f3n lenta.  - Efecto: Al enviar los mensajes a una cola, las tareas principales no se bloquean esperando a que el texto se imprima, delegando esa carga a la Tarea 7.</p>"},{"location":"Lab03/","title":"LAB 03","text":""},{"location":"Lab03/#team","title":"Team","text":"<p>Yahir Gil Mendoza</p> <p>Isaac Antonio Perez Aleman</p> <p>Pablo Eduardo L\u00f3pez Manzano</p>"},{"location":"Lab03/#1-activity-goals","title":"1) Activity Goals","text":"<ul> <li> <p>Understand the Embedded Server: Set up and manage the lightweight esp_http_server within the ESP-IDF environment.</p> </li> <li> <p>Configure URI Handlers: Register and map specific API routes for HTML interfaces and /api/led for JSON endpoints to their corresponding C functions.</p> </li> <li> <p>Process HTTP Requests: Successfully read and parse incoming request bodie, particularly extracting JSON data from POST requests to control device hardware in this case a led.</p> </li> <li> <p>Manage HTTP Headers: Assign appropriate Content-Type to server responses to ensure browsers correctly interpret them as text/html or application/json.</p> </li> </ul>"},{"location":"Lab03/#2-materials","title":"2) Materials","text":"<ul> <li>ESP32\u2011C6 with USB\u2011C cable (data-capable)</li> <li>LED + 330 \u03a9 resistor + jumper wires</li> <li>protoboard</li> <li>Motor DC</li> </ul>"},{"location":"Lab03/#3-procedure","title":"3) Procedure","text":"<ul> <li>First: we use the code given by the teacher, for follow how is the program, html and the IP.</li> </ul>"},{"location":"Lab03/#code-1-general-code","title":"Code 1:  General code","text":"<p>/  * LAB 3 \u2014 ESP32-C6 Wi-Fi + HTTP LED Control   *  * Features:  *  - Wi-Fi STA connect + reconnect using events  *  - Wait for IP (WIFI_CONNECTED_BIT)  *  - Simple GPIO LED control (gpio_reset_pin + gpio_set_direction)  *  - HTTP server:  *      GET  /         -&gt; HTML UI  *      GET  /api/led  -&gt; JSON {\"state\":0|1}  *      POST /api/led  -&gt; JSON {\"state\":0|1} sets LED, returns {\"ok\":true}  *  / // String handling and standard libraries</p>"},{"location":"Lab03/#include","title":"include","text":""},{"location":"Lab03/#include_1","title":"include","text":""},{"location":"Lab03/#include_2","title":"include  <p>// FreeRTOS and event groups</p>","text":""},{"location":"Lab03/#include-freertosfreertosh","title":"include \"freertos/FreeRTOS.h\"","text":""},{"location":"Lab03/#include-freertosevent_groupsh","title":"include \"freertos/event_groups.h\" <p>// ESP-IDF Logging and error handling</p>","text":""},{"location":"Lab03/#include-esp_logh","title":"include \"esp_log.h\"","text":""},{"location":"Lab03/#include-esp_errh","title":"include \"esp_err.h\" <p>// Wi-Fi and network</p>","text":""},{"location":"Lab03/#include-nvs_flashh","title":"include \"nvs_flash.h\"","text":""},{"location":"Lab03/#include-esp_netifh","title":"include \"esp_netif.h\"","text":""},{"location":"Lab03/#include-esp_eventh","title":"include \"esp_event.h\"","text":""},{"location":"Lab03/#include-esp_wifih","title":"include \"esp_wifi.h\" <p>// GPIO control</p>","text":""},{"location":"Lab03/#include-drivergpioh","title":"include \"driver/gpio.h\" <p>// HTTP server</p>","text":""},{"location":"Lab03/#include-esp_http_serverh","title":"include \"esp_http_server.h\" <p>/ ===================== User config ===================== /</p>","text":""},{"location":"Lab03/#define-wifi_ssid-ssid_here","title":"define WIFI_SSID \"SSID_HERE\"","text":""},{"location":"Lab03/#define-wifi_pass-pass_here","title":"define WIFI_PASS \"PASS_HERE\" <p>/ LED pin /</p>","text":""},{"location":"Lab03/#define-led_gpio-8","title":"define LED_GPIO  8 <p>/ Reconnect policy /</p>","text":""},{"location":"Lab03/#define-max_retry-10","title":"define MAX_RETRY 10 <p>/ ===================== Globals ===================== / static const char *TAG = \"LAB_3\";</p> <p>// Wi-Fi event group and bit seen in Lab 2 static EventGroupHandle_t s_wifi_event_group;</p>","text":""},{"location":"Lab03/#define-wifi_connected_bit-bit0","title":"define WIFI_CONNECTED_BIT BIT0 <p>static int s_retry = 0;// Retry count for Wi-Fi reconnects</p> <p>static int s_led_state = 0;               // 0=OFF, 1=ON static httpd_handle_t s_server = NULL;    // HTTP server handle</p> <p>/ ===================== LED helpers ===================== / static void led_init(void) {     gpio_reset_pin(LED_GPIO);     gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);</p> <pre><code>s_led_state = 0;\ngpio_set_level(LED_GPIO, s_led_state);\n\nESP_LOGI(TAG, \"LED initialized on GPIO %d (state=%d)\", LED_GPIO, s_led_state);\n</code></pre> <p>}</p> <p>/Function to set the LED from the state/ static void led_set(int on) {     s_led_state = (on != 0);     gpio_set_level(LED_GPIO, s_led_state);     ESP_LOGI(TAG, \"LED set to %d\", s_led_state); }</p> <p>/ ===================== HTTP handlers ===================== / /Remember, handlers are special functions that process HTTP requests and generate responses/</p> <p>static esp_err_t api_led_get(httpd_req_t req) {     / resp is a buffer to hold the JSON response  text in this case our jason is        either {\"state\":0} or {\"state\":1} /     char resp[32];     /sprintf is a normal printf for strings, snprintf is safer because it      limits the number of characters written to the buffer</p> <pre><code>Here we build the JSON string with the current LED state. \n*/\nsnprintf(resp, sizeof(resp), \"{\\\"state\\\":%d}\", s_led_state);\n\n/* Tell the client (browser/Postman/etc.) that the payload is JSON.\n   This sets the HTTP header: Content-Type: application/json */\nhttpd_resp_set_type(req, \"application/json\");\n\n/* Send the response body to the client.\n   - 'resp' is the payload\n   - HTTPD_RESP_USE_STRLEN tells ESP-IDF to compute the string length automatically\n     (it treats resp as a null-terminated C string). */\nhttpd_resp_send(req, resp, HTTPD_RESP_USE_STRLEN);\n\n/* Return ESP_OK so the HTTP server knows the request was handled correctly. */\nreturn ESP_OK;\n</code></pre> <p>}</p> <p>static esp_err_t api_led_post(httpd_req_t *req) {     // Basic safety: reject empty or very large payloads     if (req-&gt;content_len &lt;= 0 || req-&gt;content_len &gt; 256) {         httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, \"Invalid Content-Length\");         return ESP_FAIL;     }</p> <pre><code>char buf[257] = {0}; // +1 for null terminator\nint received = httpd_req_recv(req, buf, req-&gt;content_len);\nif (received &lt;= 0) {\n    httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, \"Empty body\");\n    return ESP_FAIL;\n}\nbuf[received] = '\\0';\n\n// Minimal parse: find \"state\":&lt;number&gt;\nint state = -1;\nchar *p = strstr(buf, \"\\\"state\\\"\");\nif (p) {\n    p = strchr(p, ':');\n    if (p) state = atoi(p + 1);\n}\n\nif (state != 0 &amp;&amp; state != 1) {\n    httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, \"state must be 0 or 1\");\n    return ESP_FAIL;\n}\n\nled_set(state);\n\nhttpd_resp_set_type(req, \"application/json\");\nhttpd_resp_sendstr(req, \"{\\\"ok\\\":true}\");\nreturn ESP_OK;\n</code></pre> <p>}</p> <p>static esp_err_t root_get_handler(httpd_req_t req) {     // Readable inline HTML     static const char INDEX_HTML =         \"&lt;!doctype html&gt;\\n\"         \"\\n\"         \"\\n\"         \"  \\n\"         \"  \\n\"         \"  ESP32-C6 LED\\n\"         \"\\n\"         \"\\n\"         \"  ESP32-C6 LED Control\\n\"         \"  ON\\n\"         \"  OFF\\n\"         \"  <p>State: ?</p>\\n\"         \"\\n\"         \"  \\n\"         \"\\n\"         \"\\n\";</p> <pre><code>httpd_resp_set_type(req, \"text/html\");\nhttpd_resp_send(req, INDEX_HTML, HTTPD_RESP_USE_STRLEN);\nreturn ESP_OK;\n</code></pre> <p>}</p> <p>static void http_server_start(void) {     httpd_config_t config = HTTPD_DEFAULT_CONFIG();     ESP_ERROR_CHECK(httpd_start(&amp;s_server, &amp;config));     ESP_LOGI(TAG, \"HTTP server started\");</p> <pre><code>httpd_uri_t root = {\n    .uri      = \"/\",\n    .method   = HTTP_GET,\n    .handler  = root_get_handler,\n    .user_ctx = NULL\n};\n\nhttpd_uri_t led_get = {\n    .uri      = \"/api/led\",\n    .method   = HTTP_GET,\n    .handler  = api_led_get,\n    .user_ctx = NULL\n};\n\nhttpd_uri_t led_post = {\n    .uri      = \"/api/led\",\n    .method   = HTTP_POST,\n    .handler  = api_led_post,\n    .user_ctx = NULL\n};\n\nESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;root));\nESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;led_get));\nESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;led_post));\n\nESP_LOGI(TAG, \"Routes registered: /  ,  GET/POST /api/led\");\n</code></pre> <p>}</p> <p>/ ===================== Wi-Fi STA connect + events ===================== /</p> <p>static void wifi_event_handler(void arg,                                esp_event_base_t event_base,                                int32_t event_id,                                void event_data) {     if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) {         ESP_LOGI(TAG, \"WIFI_EVENT_STA_START -&gt; esp_wifi_connect()\");         ESP_ERROR_CHECK(esp_wifi_connect());         return;     }</p> <pre><code>if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) {\n    if (s_retry &lt; MAX_RETRY) {\n        s_retry++;\n        ESP_LOGW(TAG, \"Disconnected. Retrying (%d/%d)...\", s_retry, MAX_RETRY);\n        ESP_ERROR_CHECK(esp_wifi_connect());\n    } else {\n        ESP_LOGE(TAG, \"Failed to connect after %d retries.\", MAX_RETRY);\n    }\n    return;\n}\n\nif (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) {\n    ip_event_got_ip_t *event = (ip_event_got_ip_t *)event_data;\n    ESP_LOGI(TAG, \"Got IP: \" IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));\n\n    s_retry = 0;\n    xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);\n    return;\n}\n</code></pre> <p>}</p> <p>static void wifi_init_sta(void) {     s_wifi_event_group = xEventGroupCreate();</p> <pre><code>ESP_ERROR_CHECK(esp_netif_init());\nESP_ERROR_CHECK(esp_event_loop_create_default());\nesp_netif_create_default_wifi_sta();\n\nwifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\nESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));\n\nESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;wifi_event_handler, NULL));\nESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;wifi_event_handler, NULL));\n\nwifi_config_t wifi_config = {0};\nstrncpy((char *)wifi_config.sta.ssid, WIFI_SSID, sizeof(wifi_config.sta.ssid));\nstrncpy((char *)wifi_config.sta.password, WIFI_PASS, sizeof(wifi_config.sta.password));\n\nESP_LOGI(TAG, \"Configuring Wi-Fi STA: SSID='%s'\", WIFI_SSID);\n\nESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));\nESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config));\nESP_ERROR_CHECK(esp_wifi_start());\n</code></pre> <p>}</p> <p>/ ===================== app_main ===================== /</p> <p>void app_main(void) {     ESP_LOGI(TAG, \"Lab D start: Wi-Fi + HTTP + LED control.\");</p> <pre><code>// NVS init (required by Wi-Fi)\nesp_err_t ret = nvs_flash_init();\nif (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {\n    ESP_ERROR_CHECK(nvs_flash_erase());\n    ESP_ERROR_CHECK(nvs_flash_init());\n} else {\n    ESP_ERROR_CHECK(ret);\n}\n\n// Connect to Wi-Fi (STA)\nwifi_init_sta();\n\n// Wait for \"got IP\" (connected)\nEventBits_t bits = xEventGroupWaitBits(\n    s_wifi_event_group,\n    WIFI_CONNECTED_BIT,\n    pdFALSE,\n    pdTRUE,\n    pdMS_TO_TICKS(30000)\n);\n\nif (!(bits &amp; WIFI_CONNECTED_BIT)) {\n    ESP_LOGE(TAG, \"Timeout waiting for Wi-Fi connection. Check SSID/PASS and 2.4 GHz.\");\n    return;\n}\n\n// Start peripherals + HTTP\nled_init();\nhttp_server_start();\n\nESP_LOGI(TAG, \"Open: http://&lt;ESP_IP&gt;/ from a device on the same network.\");\n</code></pre> <p>}</p> <ul> <li>Second: We have to add in the code the second led and change the .html for add another button.</li> </ul>","text":""},{"location":"Lab03/#code-2-with-2-buttons-and-2-leds","title":"Code 2: With 2 buttons and 2 leds","text":"<p>/  * LAB 3 \u2014 ESP32-C6 Wi-Fi + HTTP LED Control   /</p>"},{"location":"Lab03/#include_3","title":"include","text":""},{"location":"Lab03/#include_4","title":"include","text":""},{"location":"Lab03/#include-freertosfreertosh_1","title":"include \"freertos/FreeRTOS.h\"","text":""},{"location":"Lab03/#include-freertosevent_groupsh_1","title":"include \"freertos/event_groups.h\"","text":""},{"location":"Lab03/#include-esp_logh_1","title":"include \"esp_log.h\"","text":""},{"location":"Lab03/#include-esp_errh_1","title":"include \"esp_err.h\"","text":""},{"location":"Lab03/#include-nvs_flashh_1","title":"include \"nvs_flash.h\"","text":""},{"location":"Lab03/#include-esp_netifh_1","title":"include \"esp_netif.h\"","text":""},{"location":"Lab03/#include-esp_eventh_1","title":"include \"esp_event.h\"","text":""},{"location":"Lab03/#include-esp_wifih_1","title":"include \"esp_wifi.h\"","text":""},{"location":"Lab03/#include-drivergpioh_1","title":"include \"driver/gpio.h\"","text":""},{"location":"Lab03/#include-esp_http_serverh_1","title":"include \"esp_http_server.h\" <p>/ ===================== User config ===================== /</p>","text":""},{"location":"Lab03/#define-wifi_ssid-iphone","title":"define WIFI_SSID \"iPhone\"","text":""},{"location":"Lab03/#define-wifi_pass-12345678","title":"define WIFI_PASS \"12345678\"","text":""},{"location":"Lab03/#define-led_gpio-8_1","title":"define LED_GPIO   8","text":""},{"location":"Lab03/#define-led2_gpio-1-segundo-led-agregado-en-gpio-01","title":"define LED2_GPIO  1  // Segundo LED agregado en GPIO 01","text":""},{"location":"Lab03/#define-max_retry-10_1","title":"define MAX_RETRY 10 <p>/ ===================== Globals ===================== / static const char *TAG = \"LAB_3\";</p> <p>static EventGroupHandle_t s_wifi_event_group;</p>","text":""},{"location":"Lab03/#define-wifi_connected_bit-bit0_1","title":"define WIFI_CONNECTED_BIT BIT0 <p>static int s_retry = 0; static int s_led_state = 0;            // 0=OFF, 1=ON static int s_led2_state = 0;           // Estado para el segundo LED static httpd_handle_t s_server = NULL;</p> <p>/ ===================== LED helpers ===================== / static void led_init(void) {     // Inicializar LED 1     gpio_reset_pin(LED_GPIO);     gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);     s_led_state = 0;     gpio_set_level(LED_GPIO, s_led_state);</p> <pre><code>// Inicializar LED 2 (GPIO 01)\ngpio_reset_pin(LED2_GPIO);\ngpio_set_direction(LED2_GPIO, GPIO_MODE_OUTPUT);\ns_led2_state = 0;\ngpio_set_level(LED2_GPIO, s_led2_state);\n\nESP_LOGI(TAG, \"LEDs initialized: GPIO %d and GPIO %d\", LED_GPIO, LED2_GPIO);\n</code></pre> <p>}</p> <p>static void led_set(int on) {     s_led_state = (on != 0);     gpio_set_level(LED_GPIO, s_led_state); }</p> <p>static void led2_set(int on) {     s_led2_state = (on != 0);     gpio_set_level(LED2_GPIO, s_led2_state); }</p> <p>/ ===================== HTTP Handlers ===================== /</p> <p>static esp_err_t root_get_handler(httpd_req_t req) {     static const char INDEX_HTML =         \"&lt;!doctype html&gt;\\n\"         \"\\n\"         \"  \\n\"         \"  \\n\"         \"  ESP32-C6 LED Control\\n\"         \"\\n\"         \"  ESP32-C6 LED Control\\n\"         \"  <p>Control LED 1 :</p>\\n\"         \"  <p>\\n\"         \"    LED 1 ON\\n\"         \"    LED 1 OFF\\n\"         \"  </p>\\n\"         \"  <p>Control LED 2 :</p>\\n\"         \"  <p>\\n\"         \"    LED 2 ON\\n\"         \"    LED 2 OFF\\n\"         \"  </p>\\n\"         \"\\n\";</p> <pre><code>httpd_resp_set_type(req, \"text/html\");\nhttpd_resp_send(req, INDEX_HTML, HTTPD_RESP_USE_STRLEN);\nreturn ESP_OK;\n</code></pre> <p>}</p> <p>static esp_err_t ledon_get_handler(httpd_req_t req) {     led_set(1);     static const char RESP = \"&lt;!doctype html&gt;LED 1 is now: ON<p>Back</p>\";     httpd_resp_set_type(req, \"text/html\");     httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>static esp_err_t ledoff_get_handler(httpd_req_t req) {     led_set(0);     static const char RESP = \"&lt;!doctype html&gt;LED 1 is now: OFF<p>Back</p>\";     httpd_resp_set_type(req, \"text/html\");     httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>static esp_err_t led2on_get_handler(httpd_req_t req) {     led2_set(1);     static const char RESP = \"&lt;!doctype html&gt;LED 2 is now: ON<p>Back</p>\";     httpd_resp_set_type(req, \"text/html\");     httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>static esp_err_t led2off_get_handler(httpd_req_t req) {     led2_set(0);     static const char RESP = \"&lt;!doctype html&gt;LED 2 is now: OFF<p>Back</p>\";     httpd_resp_set_type(req, \"text/html\");     httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>/ ===================== HTTP Server Start + Route Registration ===================== /</p> <p>static void http_server_start(void) {     httpd_config_t config = HTTPD_DEFAULT_CONFIG();     ESP_ERROR_CHECK(httpd_start(&amp;s_server, &amp;config));</p> <pre><code>httpd_uri_t root = { .uri = \"/\", .method = HTTP_GET, .handler = root_get_handler };\nhttpd_uri_t ledon = { .uri = \"/ledon\", .method = HTTP_GET, .handler = ledon_get_handler };\nhttpd_uri_t ledoff = { .uri = \"/ledoff\", .method = HTTP_GET, .handler = ledoff_get_handler };\nhttpd_uri_t led2on = { .uri = \"/led2on\", .method = HTTP_GET, .handler = led2on_get_handler };\nhttpd_uri_t led2off = { .uri = \"/led2off\", .method = HTTP_GET, .handler = led2off_get_handler };\n\nESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;root));\nESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;ledon));\nESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;ledoff));\nESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;led2on));\nESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;led2off));\n\nESP_LOGI(TAG, \"Routes registered: LED 1 and LED 2 controls available.\");\n</code></pre> <p>}</p> <p>/ ===================== Wi-Fi STA connect + events (Sin cambios) ===================== /</p> <p>static void wifi_event_handler(void arg, esp_event_base_t event_base, int32_t event_id, void event_data) {     if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) {         esp_wifi_connect();     } else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) {         if (s_retry &lt; MAX_RETRY) {             s_retry++;             esp_wifi_connect();         }     } else if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) {         s_retry = 0;         xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);     } }</p> <p>static void wifi_init_sta(void) {     s_wifi_event_group = xEventGroupCreate();     esp_netif_init();     esp_event_loop_create_default();     esp_netif_create_default_wifi_sta();     wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();     esp_wifi_init(&amp;cfg);     esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;wifi_event_handler, NULL);     esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;wifi_event_handler, NULL);     wifi_config_t wifi_config = {0};     strncpy((char )wifi_config.sta.ssid, WIFI_SSID, sizeof(wifi_config.sta.ssid));     strncpy((char )wifi_config.sta.password, WIFI_PASS, sizeof(wifi_config.sta.password));     esp_wifi_set_mode(WIFI_MODE_STA);     esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config);     esp_wifi_start(); }</p> <p>/ ===================== app_main ===================== /</p> <p>void app_main(void) {     esp_err_t ret = nvs_flash_init();     if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {         ESP_ERROR_CHECK(nvs_flash_erase());         ESP_ERROR_CHECK(nvs_flash_init());     }     wifi_init_sta();     xEventGroupWaitBits(s_wifi_event_group, WIFI_CONNECTED_BIT, pdFALSE, pdTRUE, pdMS_TO_TICKS(30000));</p> <pre><code>led_init();\nhttp_server_start();\n</code></pre> <p>}</p> <ul> <li>Third: For this step, we hace to add a counter, this counter is for when we push on or off, the counter will go count each push. </li> </ul>","text":""},{"location":"Lab03/#code-3-add-the-counter","title":"Code 3: Add the counter.","text":"<p>/  * LAB 3 \u2014 ESP32-C6 Wi-Fi + HTTP LED Control + Auto-Refresh Counter  /</p>"},{"location":"Lab03/#include_5","title":"include","text":""},{"location":"Lab03/#include_6","title":"include","text":""},{"location":"Lab03/#include-freertosfreertosh_2","title":"include \"freertos/FreeRTOS.h\"","text":""},{"location":"Lab03/#include-freertostaskh","title":"include \"freertos/task.h\"","text":""},{"location":"Lab03/#include-freertosevent_groupsh_2","title":"include \"freertos/event_groups.h\"","text":""},{"location":"Lab03/#include-esp_logh_2","title":"include \"esp_log.h\"","text":""},{"location":"Lab03/#include-esp_errh_2","title":"include \"esp_err.h\"","text":""},{"location":"Lab03/#include-nvs_flashh_2","title":"include \"nvs_flash.h\"","text":""},{"location":"Lab03/#include-esp_netifh_2","title":"include \"esp_netif.h\"","text":""},{"location":"Lab03/#include-esp_eventh_2","title":"include \"esp_event.h\"","text":""},{"location":"Lab03/#include-esp_wifih_2","title":"include \"esp_wifi.h\"","text":""},{"location":"Lab03/#include-drivergpioh_2","title":"include \"driver/gpio.h\"","text":""},{"location":"Lab03/#include-esp_http_serverh_2","title":"include \"esp_http_server.h\" <p>/ ===================== User config ===================== /</p>","text":""},{"location":"Lab03/#define-wifi_ssid-xr-yahir","title":"define WIFI_SSID \"Xr Yahir\"","text":""},{"location":"Lab03/#define-wifi_pass-12345678_1","title":"define WIFI_PASS \"12345678\"","text":""},{"location":"Lab03/#define-led_gpio-8_2","title":"define LED_GPIO   8","text":""},{"location":"Lab03/#define-led2_gpio-1","title":"define LED2_GPIO  1","text":""},{"location":"Lab03/#define-btn_gpio-4","title":"define BTN_GPIO   4","text":""},{"location":"Lab03/#define-max_retry-10_2","title":"define MAX_RETRY 10 <p>/ ===================== Globals ===================== / static const char *TAG = \"LAB_3\";</p> <p>static EventGroupHandle_t s_wifi_event_group;</p>","text":""},{"location":"Lab03/#define-wifi_connected_bit-bit0_2","title":"define WIFI_CONNECTED_BIT BIT0 <p>static int s_retry = 0; static int s_led_state = 0;           static int s_led2_state = 0;          static int s_btn_counter = 0;         static httpd_handle_t s_server = NULL;</p> <p>/ ===================== Peripherals helpers ===================== / static void led_init(void) {     gpio_reset_pin(LED_GPIO);     gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);     s_led_state = 0;     gpio_set_level(LED_GPIO, s_led_state);</p> <pre><code>gpio_reset_pin(LED2_GPIO);\ngpio_set_direction(LED2_GPIO, GPIO_MODE_OUTPUT);\ns_led2_state = 0;\ngpio_set_level(LED2_GPIO, s_led2_state);\n\ngpio_reset_pin(BTN_GPIO);\ngpio_set_direction(BTN_GPIO, GPIO_MODE_INPUT);\ngpio_pullup_en(BTN_GPIO);\n\nESP_LOGI(TAG, \"LEDs and Button initialized.\");\n</code></pre> <p>}</p> <p>void button_task(void *pvParameter) {     int last_state = 1;     while(1) {         int current_state = gpio_get_level(BTN_GPIO);         if (last_state == 1 &amp;&amp; current_state == 0) {             s_btn_counter++;             vTaskDelay(pdMS_TO_TICKS(200));          }         last_state = current_state;         vTaskDelay(pdMS_TO_TICKS(50));     } }</p> <p>static void led_set(int on) {     s_led_state = (on != 0);     gpio_set_level(LED_GPIO, s_led_state); }</p> <p>static void led2_set(int on) {     s_led2_state = (on != 0);     gpio_set_level(LED2_GPIO, s_led2_state); }</p> <p>/ ===================== HTTP Handlers ===================== /</p> <p>static esp_err_t status_get_handler(httpd_req_t *req) {     char resp[16];     snprintf(resp, sizeof(resp), \"%d\", s_btn_counter);     httpd_resp_send(req, resp, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>static esp_err_t root_get_handler(httpd_req_t req) {     static const char INDEX_HTML =         \"&lt;!doctype html&gt;\\n\"         \"\\n\"         \"  \\n\"         \"  \\n\"         \"  ESP32-C6 LED Control\\n\"         \"\\n\"         \"  ESP32-C6 LED Control\\n\" <pre><code>    \"  &lt;p&gt;&lt;strong&gt;Control LED 1 :&lt;/strong&gt;&lt;/p&gt;\\n\"\n    \"  &lt;p&gt;\\n\"\n    \"    &lt;a href='/ledon'&gt;&lt;button&gt;LED 1 ON&lt;/button&gt;&lt;/a&gt;\\n\"\n    \"    &lt;a href='/ledoff'&gt;&lt;button&gt;LED 1 OFF&lt;/button&gt;&lt;/a&gt;\\n\"\n    \"  &lt;/p&gt;\\n\"\n    \"  &lt;p&gt;&lt;strong&gt;Control LED 2 :&lt;/strong&gt;&lt;/p&gt;\\n\"\n    \"  &lt;p&gt;\\n\"\n    \"    &lt;a href='/led2on'&gt;&lt;button&gt;LED 2 ON&lt;/button&gt;&lt;/a&gt;\\n\"\n    \"    &lt;a href='/led2off'&gt;&lt;button&gt;LED 2 OFF&lt;/button&gt;&lt;/a&gt;\\n\"\n    \"  &lt;p&gt;&lt;strong&gt;Contador: &lt;span id='v'&gt;0&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;\\n\"\n\n    \"  &lt;/p&gt;\\n\"\n    \"  &lt;script&gt;\\n\"\n    \"    function refresh() {\\n\"\n    \"      fetch('/status').then(r =&gt; r.text()).then(d =&gt; {\\n\"\n    \"        document.getElementById('v').innerText = d;\\n\"\n    \"      });\\n\"\n    \"    }\\n\"\n    \"    setInterval(refresh, 1000);\\n\"\n    \"    refresh();\\n\"\n    \"  &lt;/script&gt;\\n\"\n    \"&lt;/body&gt;&lt;/html&gt;\\n\";\n\nhttpd_resp_set_type(req, \"text/html\");\nhttpd_resp_send(req, INDEX_HTML, HTTPD_RESP_USE_STRLEN);\nreturn ESP_OK;\n</code></pre> <p>}</p> <p>static esp_err_t ledon_get_handler(httpd_req_t req) {     led_set(1);     static const char RESP = \"&lt;!doctype html&gt;LED 1 is now: ON<p>Back</p>\";     httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>static esp_err_t ledoff_get_handler(httpd_req_t req) {     led_set(0);     static const char RESP = \"&lt;!doctype html&gt;LED 1 is now: OFF<p>Back</p>\";     httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>static esp_err_t led2on_get_handler(httpd_req_t req) {     led2_set(1);     static const char RESP = \"&lt;!doctype html&gt;LED 2 is now: ON<p>Back</p>\";     httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>static esp_err_t led2off_get_handler(httpd_req_t req) {     led2_set(0);     static const char RESP = \"&lt;!doctype html&gt;LED 2 is now: OFF<p>Back</p>\";     httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>/ ===================== HTTP Server Start ===================== /</p> <p>static void http_server_start(void) {     httpd_config_t config = HTTPD_DEFAULT_CONFIG();     ESP_ERROR_CHECK(httpd_start(&amp;s_server, &amp;config));</p> <pre><code>httpd_uri_t root = { .uri = \"/\", .method = HTTP_GET, .handler = root_get_handler };\nhttpd_uri_t stat = { .uri = \"/status\", .method = HTTP_GET, .handler = status_get_handler };\nhttpd_uri_t ledon = { .uri = \"/ledon\", .method = HTTP_GET, .handler = ledon_get_handler };\nhttpd_uri_t ledoff = { .uri = \"/ledoff\", .method = HTTP_GET, .handler = ledoff_get_handler };\nhttpd_uri_t led2on = { .uri = \"/led2on\", .method = HTTP_GET, .handler = led2on_get_handler };\nhttpd_uri_t led2off = { .uri = \"/led2off\", .method = HTTP_GET, .handler = led2off_get_handler };\n\nhttpd_register_uri_handler(s_server, &amp;root);\nhttpd_register_uri_handler(s_server, &amp;stat);\nhttpd_register_uri_handler(s_server, &amp;ledon);\nhttpd_register_uri_handler(s_server, &amp;ledoff);\nhttpd_register_uri_handler(s_server, &amp;led2on);\nhttpd_register_uri_handler(s_server, &amp;led2off);\n</code></pre> <p>}</p> <p>/ ===================== Wi-Fi STA (Sin cambios) ===================== /</p> <p>static void wifi_event_handler(void arg, esp_event_base_t event_base, int32_t event_id, void event_data) {     if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) esp_wifi_connect();     else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) {         if (s_retry &lt; MAX_RETRY) { s_retry++; esp_wifi_connect(); }     } else if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) {         s_retry = 0; xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);     } }</p> <p>static void wifi_init_sta(void) {     s_wifi_event_group = xEventGroupCreate();     esp_netif_init();     esp_event_loop_create_default();     esp_netif_create_default_wifi_sta();     wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();     esp_wifi_init(&amp;cfg);     esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;wifi_event_handler, NULL);     esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;wifi_event_handler, NULL);     wifi_config_t wifi_config = { .sta = { .ssid = WIFI_SSID, .password = WIFI_PASS } };     esp_wifi_set_mode(WIFI_MODE_STA);     esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config);     esp_wifi_start(); }</p> <p>void app_main(void) {     esp_err_t ret = nvs_flash_init();     if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {         ESP_ERROR_CHECK(nvs_flash_erase());         ESP_ERROR_CHECK(nvs_flash_init());     }     wifi_init_sta();     xEventGroupWaitBits(s_wifi_event_group, WIFI_CONNECTED_BIT, pdFALSE, pdTRUE, portMAX_DELAY);</p> <pre><code>led_init();\nxTaskCreate(button_task, \"button_task\", 2048, NULL, 5, NULL);\nhttp_server_start();\n</code></pre> <p>}</p> <ul> <li>Fourth: Finally we add to the code the slider for control a dc motor. </li> </ul>","text":""},{"location":"Lab03/#code-4-slider-for-control-dc-motor","title":"Code 4: Slider for control DC motor","text":""},{"location":"Lab03/#include_7","title":"include","text":""},{"location":"Lab03/#include_8","title":"include","text":""},{"location":"Lab03/#include_9","title":"include","text":""},{"location":"Lab03/#include-freertosfreertosh_3","title":"include \"freertos/FreeRTOS.h\"","text":""},{"location":"Lab03/#include-freertostaskh_1","title":"include \"freertos/task.h\"","text":""},{"location":"Lab03/#include-freertosevent_groupsh_3","title":"include \"freertos/event_groups.h\"","text":""},{"location":"Lab03/#include-esp_logh_3","title":"include \"esp_log.h\"","text":""},{"location":"Lab03/#include-esp_errh_3","title":"include \"esp_err.h\"","text":""},{"location":"Lab03/#include-nvs_flashh_3","title":"include \"nvs_flash.h\"","text":""},{"location":"Lab03/#include-esp_netifh_3","title":"include \"esp_netif.h\"","text":""},{"location":"Lab03/#include-esp_eventh_3","title":"include \"esp_event.h\"","text":""},{"location":"Lab03/#include-esp_wifih_3","title":"include \"esp_wifi.h\"","text":""},{"location":"Lab03/#include-drivergpioh_3","title":"include \"driver/gpio.h\"","text":""},{"location":"Lab03/#include-driverledch-libreria-para-pwm-motor","title":"include \"driver/ledc.h\" // Librer\u00eda para PWM (Motor)","text":""},{"location":"Lab03/#include-esp_http_serverh_3","title":"include \"esp_http_server.h\" <p>/ ===================== User config ===================== /</p>","text":""},{"location":"Lab03/#define-wifi_ssid-xr-yahir_1","title":"define WIFI_SSID \"Xr Yahir\"","text":""},{"location":"Lab03/#define-wifi_pass-12345678_2","title":"define WIFI_PASS \"12345678\"","text":""},{"location":"Lab03/#define-led_gpio-8_3","title":"define LED_GPIO   8","text":""},{"location":"Lab03/#define-led2_gpio-1_1","title":"define LED2_GPIO  1","text":""},{"location":"Lab03/#define-btn_gpio-4_1","title":"define BTN_GPIO   4","text":""},{"location":"Lab03/#define-motor_gpio-6-motor-en-gpio-06","title":"define MOTOR_GPIO 6  // Motor en GPIO 06","text":""},{"location":"Lab03/#define-max_retry-10_3","title":"define MAX_RETRY  10 <p>// Configuraci\u00f3n PWM Motor</p>","text":""},{"location":"Lab03/#define-ledc_timer-ledc_timer_0","title":"define LEDC_TIMER              LEDC_TIMER_0","text":""},{"location":"Lab03/#define-ledc_mode-ledc_low_speed_mode","title":"define LEDC_MODE               LEDC_LOW_SPEED_MODE","text":""},{"location":"Lab03/#define-ledc_channel-ledc_channel_0","title":"define LEDC_CHANNEL            LEDC_CHANNEL_0","text":""},{"location":"Lab03/#define-ledc_duty_res-ledc_timer_10_bit-resolucion-de-0-a-1023","title":"define LEDC_DUTY_RES           LEDC_TIMER_10_BIT // Resoluci\u00f3n de 0 a 1023","text":""},{"location":"Lab03/#define-ledc_frequency-5000-5-khz","title":"define LEDC_FREQUENCY          (5000)            // 5 kHz <p>/ ===================== Globals ===================== / static const char *TAG = \"LAB_3\"; static EventGroupHandle_t s_wifi_event_group;</p>","text":""},{"location":"Lab03/#define-wifi_connected_bit-bit0_3","title":"define WIFI_CONNECTED_BIT BIT0 <p>static int s_retry = 0; static int s_led_state = 0;           static int s_led2_state = 0;          static int s_btn_counter = 0;         static httpd_handle_t s_server = NULL;</p> <p>/ ===================== Peripherals helpers ===================== / static void peripherals_init(void) {     // LEDs     gpio_reset_pin(LED_GPIO);     gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);     gpio_set_level(LED_GPIO, 0);</p> <pre><code>gpio_reset_pin(LED2_GPIO);\ngpio_set_direction(LED2_GPIO, GPIO_MODE_OUTPUT);\ngpio_set_level(LED2_GPIO, 0);\n\n// Bot\u00f3n\ngpio_reset_pin(BTN_GPIO);\ngpio_set_direction(BTN_GPIO, GPIO_MODE_INPUT);\ngpio_pullup_en(BTN_GPIO);\n\n// Configuraci\u00f3n PWM para el Motor (GPIO 06)\nledc_timer_config_t ledc_timer = {\n    .speed_mode       = LEDC_MODE,\n    .timer_num        = LEDC_TIMER,\n    .duty_resolution  = LEDC_DUTY_RES,\n    .freq_hz          = LEDC_FREQUENCY,\n    .clk_cfg          = LEDC_AUTO_CLK\n};\nledc_timer_config(&amp;ledc_timer);\n\nledc_channel_config_t ledc_channel = {\n    .speed_mode     = LEDC_MODE,\n    .channel        = LEDC_CHANNEL,\n    .timer_sel      = LEDC_TIMER,\n    .intr_type      = LEDC_INTR_DISABLE,\n    .gpio_num       = MOTOR_GPIO,\n    .duty           = 0, // Inicia apagado\n    .hpoint         = 0\n};\nledc_channel_config(&amp;ledc_channel);\n\nESP_LOGI(TAG, \"Peripherals (LEDs, Button, Motor PWM) initialized.\");\n</code></pre> <p>}</p> <p>void button_task(void *pvParameter) {     int last_state = 1;     while(1) {         int current_state = gpio_get_level(BTN_GPIO);         if (last_state == 1 &amp;&amp; current_state == 0) {             s_btn_counter++;             vTaskDelay(pdMS_TO_TICKS(200));          }         last_state = current_state;         vTaskDelay(pdMS_TO_TICKS(50));     } }</p> <p>static void led_set(int on) {     s_led_state = (on != 0);     gpio_set_level(LED_GPIO, s_led_state); }</p> <p>static void led2_set(int on) {     s_led2_state = (on != 0);     gpio_set_level(LED2_GPIO, s_led2_state); }</p> <p>/ ===================== HTTP Handlers ===================== /</p> <p>static esp_err_t status_get_handler(httpd_req_t *req) {     char resp[16];     snprintf(resp, sizeof(resp), \"%d\", s_btn_counter);     httpd_resp_send(req, resp, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>// Handler para la velocidad del motor static esp_err_t motor_set_handler(httpd_req_t *req) {     char buf[10];     int ret = httpd_req_get_url_query_str(req, buf, sizeof(buf));     if (ret == ESP_OK) {         char val_str[10];         if (httpd_query_key_value(buf, \"v\", val_str, sizeof(val_str)) == ESP_OK) {             int speed = atoi(val_str); // Valor de 0 a 100             uint32_t duty = (speed * 1023) / 100; // Mapeo a resoluci\u00f3n de 10 bits             ledc_set_duty(LEDC_MODE, LEDC_CHANNEL, duty);             ledc_update_duty(LEDC_MODE, LEDC_CHANNEL);         }     }     httpd_resp_send(req, NULL, 0);     return ESP_OK; }</p> <p>static esp_err_t root_get_handler(httpd_req_t req) {     static const char INDEX_HTML =         \"&lt;!doctype html&gt;\\n\"         \"\\n\"         \"  \\n\"         \"  \\n\"         \"  ESP32-C6 Control\\n\"         \"\\n\"         \"  ESP32-C6 LED Control\\n\"         \"  <p>Control LED 1 :</p>\\n\"         \"  <p>\\n\"         \"    LED 1 ON\\n\"         \"    LED 1 OFF\\n\"         \"  </p>\\n\"         \"  <p>Control LED 2 :</p>\\n\"         \"  <p>\\n\"         \"    LED 2 ON\\n\"         \"    LED 2 OFF\\n\"         \"  </p>\\n\"         \"  <p>Contador: 0</p>\\n\"         \"  \\n\"         \"  Velocidad del Motor \\n\"         \"  \\n\"         \"  \\n\"         \"\\n\";</p> <pre><code>httpd_resp_set_type(req, \"text/html\");\nhttpd_resp_send(req, INDEX_HTML, HTTPD_RESP_USE_STRLEN);\nreturn ESP_OK;\n</code></pre> <p>}</p> <p>static esp_err_t ledon_get_handler(httpd_req_t req) {     led_set(1);     static const char RESP = \"&lt;!doctype html&gt;LED 1 is now: ON<p>Back</p>\";     httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>static esp_err_t ledoff_get_handler(httpd_req_t req) {     led_set(0);     static const char RESP = \"&lt;!doctype html&gt;LED 1 is now: OFF<p>Back</p>\";     httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>static esp_err_t led2on_get_handler(httpd_req_t req) {     led2_set(1);     static const char RESP = \"&lt;!doctype html&gt;LED 2 is now: ON<p>Back</p>\";     httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>static esp_err_t led2off_get_handler(httpd_req_t req) {     led2_set(0);     static const char RESP = \"&lt;!doctype html&gt;LED 2 is now: OFF<p>Back</p>\";     httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);     return ESP_OK; }</p> <p>/ ===================== HTTP Server Start ===================== /</p> <p>static void http_server_start(void) {     httpd_config_t config = HTTPD_DEFAULT_CONFIG();     ESP_ERROR_CHECK(httpd_start(&amp;s_server, &amp;config));</p> <pre><code>httpd_uri_t root = { .uri = \"/\", .method = HTTP_GET, .handler = root_get_handler };\nhttpd_uri_t stat = { .uri = \"/status\", .method = HTTP_GET, .handler = status_get_handler };\nhttpd_uri_t mtr  = { .uri = \"/motor\",  .method = HTTP_GET, .handler = motor_set_handler };\nhttpd_uri_t ledon = { .uri = \"/ledon\", .method = HTTP_GET, .handler = ledon_get_handler };\nhttpd_uri_t ledoff = { .uri = \"/ledoff\", .method = HTTP_GET, .handler = ledoff_get_handler };\nhttpd_uri_t led2on = { .uri = \"/led2on\", .method = HTTP_GET, .handler = led2on_get_handler };\nhttpd_uri_t led2off = { .uri = \"/led2off\", .method = HTTP_GET, .handler = led2off_get_handler };\n\nhttpd_register_uri_handler(s_server, &amp;root);\nhttpd_register_uri_handler(s_server, &amp;stat);\nhttpd_register_uri_handler(s_server, &amp;mtr);\nhttpd_register_uri_handler(s_server, &amp;ledon);\nhttpd_register_uri_handler(s_server, &amp;ledoff);\nhttpd_register_uri_handler(s_server, &amp;led2on);\nhttpd_register_uri_handler(s_server, &amp;led2off);\n</code></pre> <p>}</p> <p>/ ===================== Wi-Fi STA ===================== /</p> <p>static void wifi_event_handler(void arg, esp_event_base_t event_base, int32_t event_id, void event_data) {     if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) esp_wifi_connect();     else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) {         if (s_retry &lt; MAX_RETRY) { s_retry++; esp_wifi_connect(); }     } else if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) {         s_retry = 0; xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);     } }</p> <p>static void wifi_init_sta(void) {     s_wifi_event_group = xEventGroupCreate();     esp_netif_init();     esp_event_loop_create_default();     esp_netif_create_default_wifi_sta();     wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();     esp_wifi_init(&amp;cfg);     esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;wifi_event_handler, NULL);     esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;wifi_event_handler, NULL);     wifi_config_t wifi_config = { .sta = { .ssid = WIFI_SSID, .password = WIFI_PASS } };     esp_wifi_set_mode(WIFI_MODE_STA);     esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config);     esp_wifi_start(); }</p> <p>void app_main(void) {     esp_err_t ret = nvs_flash_init();     if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {         ESP_ERROR_CHECK(nvs_flash_erase());         ESP_ERROR_CHECK(nvs_flash_init());     }     wifi_init_sta();     xEventGroupWaitBits(s_wifi_event_group, WIFI_CONNECTED_BIT, pdFALSE, pdTRUE, portMAX_DELAY);</p> <pre><code>peripherals_init();\nxTaskCreate(button_task, \"button_task\", 2048, NULL, 5, NULL);\nhttp_server_start();\n</code></pre> <p>}</p>","text":""},{"location":"Lab03/#results","title":"Results","text":"<ul> <li>2 leds and 2 buttons in the page</li> </ul> <ul> <li>The 2 buttons in the page </li> </ul> <ul> <li>2 buttons, 2 leds and the button for counter</li> </ul> <ul> <li>Page </li> </ul> <ul> <li>Motor DC and the slider</li> </ul> <ul> <li>Motor DC run</li> </ul> <p>Video motor DC]</p>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"}]}